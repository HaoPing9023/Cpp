//在库存管理系统中，跟踪和调节商品库存量是关键任务之一。
//小明经营的仓库中存有多种商品，这些商品根据类别和规格被有序地分类并编号，
//编号范围从1至n。初始时，每种商品的库存量均为0。
//为了高效地监控和调整库存量，小明的管理团队设计了m个操作，每个操作涉及到一个特定的商品区间，
//即一段连续的商品编号范围(例如区间[L, R])。
//执行这些操作时，区间内每种商品的库存量都将增加1。
//然而，在某些情况下，管理团队可能会决定不执行某些操作，
//使得这些操作涉及的商品区间内的库存量不会发生改变，维持原有的状态。
//现在，管理团队需要一个评估机制，来确定如果某个操作未被执行，
//那么最终会有多少种商品的库存量为 0。
//对此，请你为管理团队计算出每个操作未执行时，库存量为 0的商品的种类数。


#define _CRT_SECURE_NO_WARNINGS 1

#include <iostream>
using namespace std;
const int N = 3e5 + 9;
struct mp {
    int l, r;   //表示区间
}a[N];
int diff[N];
int main()
{
    int n, m; cin >> n >> m;
    for (int i = 1; i <= m; ++i) cin >> a[i].l >> a[i].r;
    for (int i = 1; i <= m; ++i)
    {
        //执行每个区间的操作
        diff[a[i].l]++;
        diff[a[i].r + 1]--;
    }
    //做前缀和恢复成原数组，终止条件需要到 n 
    for (int i = 1; i <= n; ++i) diff[i] += diff[i - 1];
    int ans = 0;
    for (int i = 1; i <= n; ++i)
        //计算操作后库存量也为0的数量
        if (diff[i] == 0) ans++;
    for (int i = 1; i <= m; ++i)
    {
        int res = 0;
        //再每次操作区间里，要是数量只有 1 ，那么说明不执行的话就为 0 了
        for (int j = a[i].l; j <= a[i].r; ++j)
            if (diff[j] == 1) res++;   //只计算为 1 的数量就行
        cout << res + ans << '\n';
    }
    return 0;
}